<script>
  import PageHeader from "./partials/PageHeader.svelte";
  import { DateTime } from "luxon";
  export let timelineData;
  // Group entries by date
  function groupByDate(entries) {
    if (!entries) return [];

    const groups = {};

    entries.forEach((entry) => {
      // Extract just the date part (without time)
      const dateOnly = entry.formattedDate.split(" at ")[0];

      if (!groups[dateOnly]) {
        groups[dateOnly] = [];
      }
      groups[dateOnly].push(entry);
    });

    // Convert to array and sort by date (newest first)
    return Object.entries(groups)
      .map(([date, entries]) => ({
        date,
        entries: entries.sort((a, b) => new Date(b.date) - new Date(a.date)), // Sort commits within date: newest first (latest time at top)
      }))
      .sort(
        (a, b) => new Date(b.entries[0].date) - new Date(a.entries[0].date) // Sort date groups: newest first
      );
  }

  $: groupedEntries = groupByDate(timelineData?.entries);

  function shortenText(text, maxLength = 30) {
    if (text.length <= maxLength) return text;
    return text.slice(0, maxLength) + "...";
  }

  function getGitHubStats(timelineData) {
    const stats = {
      totalCommits: 0,
      totalMerges: 0,
      totalPRs: 0,
    };

    const uniquePRs = new Set();

    timelineData.entries.forEach((entry) => {
      // Clean the message
      if (entry.message.startsWith(":")) {
        entry.message = entry.message.replace(/^:\s*/, "");
      }

      stats.totalCommits++;

      if (entry.isMerge === true) {
        stats.totalMerges++;
      }

      if (entry.prNumber) {
        uniquePRs.add(entry.prNumber);
      }
    });

    stats.totalPRs = uniquePRs.size;

    return stats;
  }

  // Usage
  const result = getGitHubStats(timelineData);
</script>

<PageHeader>
  <h1>
    {result.totalCommits} commits. {result.totalMerges} merges. {result.totalPRs} pull requests. One rebase.
  </h1>
  <div class="flex max-w-xl flex-col gap-12">
    <p>
      Design isn’t neat. It’s organised chaos.
      <br />
      It’s a ball of string that slowly unravels.
      <br />
      Huh...Just like me.
    </p>
  </div>
</PageHeader>

<section class="timeline-section flex max-w-2xl flex-col gap-12 lg:mx-2 2xl:mt-5 2xl:w-5xl">
  <div class="timeline-reveal group flex flex-col gap-12">
    <div class="timeline-groups flex flex-col">
      {#each groupedEntries as group}
        <div class="date-group">
          <h3 class="date-header mb-12">
            {group.date}
          </h3>
          <ul class="timeline-entries mb-12 flex flex-col gap-12">
            {#each group.entries as entry}
              <li class="timeline-entry space-y-2" data-type={entry.type}>
                <div class="entry-content space-y-3">
                  {#if entry.branchMerged && entry.intoBranch}
                    <p class="message text-sm text-gray-100">
                      <span class="merge-info">
                        <span class="merged-branch">
                          {entry.branchDisplay === entry.branchMerged ? entry.intoBranch : entry.branchDisplay}
                        </span>
                        <span class="merge-arrow text-yellow-300">←</span>
                        <span class="into-branch">{entry.branchMerged}</span>
                      </span>
                    </p>
                  {:else}
                    <p class="text-body text-sm/relaxed text-pretty">
                      {entry.message}
                    </p>
                  {/if}
                  <ul class="entry-meta text-xxs text-primary flex flex-row gap-6">
                    {#if entry.branchMerged && entry.intoBranch}
                      <li>
                        <span class="h-[18px] w-[18px]">
                          <iconify-icon
                            icon="carbon:direction-merge-filled"
                            width="18"
                            height="18"
                            class="text-yellow-300"
                          ></iconify-icon>
                        </span>
                        Merge
                      </li>
                    {:else}
                      <li class="branch-display">
                        <span class="h-[18px] w-[18px]">
                          <iconify-icon icon="carbon:branch" width="18" height="18" class="text-body"></iconify-icon>
                        </span>
                        {shortenText(entry.branchDisplay)}
                      </li>
                    {/if}
                    <li class="version-debug">
                      <span class="h-[18px] w-[18px]">
                        <iconify-icon icon="carbon:version" width="18" height="18" class="text-body"></iconify-icon>
                      </span>
                      {entry.version}
                    </li>
                    <li class="time">
                      <span class="h-[18px] w-[18px]">
                        <iconify-icon
                          icon="carbon:network-time-protocol"
                          width="18"
                          height="18"
                          class="text-body"
                        ></iconify-icon>
                      </span>
                      {DateTime.fromISO(entry.date).toFormat("TT ZZ")}
                    </li>
                  </ul>
                </div>
              </li>
            {/each}
          </ul>
        </div>
      {/each}
    </div>
  </div>
</section>

<style>
  @reference "@styles/global.css";
  h1 {
    font-feature-settings: "ss01" 1;
  }
  h3 {
    @apply text-3xl;
  }
  p {
    @apply text-body text-xl/relaxed;
  }
  .entry-meta {
    li {
      @apply flex flex-row items-center gap-3 text-sm uppercase;
    }
  }
</style>
